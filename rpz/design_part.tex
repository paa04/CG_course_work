\chapter{Конструкторская часть}

\section{Требования к программному обеспечению}

Разрабатываемое программное обеспечение должно предоставлять следующие функциональные возможности:

\subsection*{Генерация карты высот}

\begin{itemize}
	\item Задание размера матрицы высот;
	\item задание значения шума.
\end{itemize}

\subsection*{Ландшафт}

\begin{itemize}
	\item Задание высоты ландшафта;
	\item задание уровня воды.
\end{itemize}

\subsection*{Источник света}

\begin{itemize}
	\item Задание положения источника света.
\end{itemize}

\subsection*{Преобразования ландшафта}

\begin{itemize}
	\item Поворот ландшафта;
	\item перемещение ландшафта;
	\item масштабирование ландшафта.
\end{itemize}

\section{Общий алгоритм поставленной задачи}

\begin{enumerate}
	\item Сгенерировать или загрузить карту высот ландшафта;
	\item рассчитать экранные координаты;
	\item рассчитать вектор нормали для каждого полигона;
	\item рассчитать интенсивность для каждого полигона на основе вектора нормали;
	\item рассчитать цвет каждого полигона на основе карты высот;
	\item отобразить сцену на экран.
\end{enumerate}

\section{Описания алгоритмов}

\subsection{Алгоритм триангуляции равномерной сетки}

Пусть есть карта высот заданная равномерное сеткой $m$ размером $n \times n$.

\begin{enumerate}
	\item получить элементы карты высот $m[i][j], m[i][j + 1], m[i + 1][j], m[i + 1][j + 1]$, где $i, j \in [0, n - 1]$;
	\item сохранить треугольник составленный из вершин $m[i][j], m[i + 1][j], m[i + 1][j + 1]$;
	\item сохранить треугольник составленный из вершин $m[i][j], m[i][j + 1], m[i + 1][j + 1]$.
\end{enumerate}

\subsection{Алгоритм diamond--square}

Пусть есть карта высот заданная равномерное сеткой $m$ размером $n \times n$.

Пусть $step wide = n$

Шаг <<square>>:

\begin{enumerate}
	\item Вычислить расстояние до соседей: $neighbour dist = step wide / 2$;
	\item вычислить среднее значение высот по ячейкам индексы которых вычисляются как сумма индексов текущей ячейки и матричное произведение $(neighbour dist) \times (offset)$, где $offset \in \{(-1, -1), (1, 1), (1, -1), (-1, 1)\}\}$;
	\item прибавить к этому значению случайный шум;
	\item записать полученное значение в текущую ячейку.
\end{enumerate}

Шаг <<diamond>>:

\begin{enumerate}
	\item Вычислить расстояние до соседей: $neighbour dist = step wide / 2$;
	\item вычислить среднее значение высот по ячейкам индексы которых вычисляются как сумма индексов текущей ячейки и матричное произведение $(neighbour dist) \times (offset)$, где $offset \in \{(0, -1), (0, 1), (1, 0), (-1, 0)\}\}$;
	\item прибавить к этому значению случайный шум;
	\item записать полученное значение в текущую ячейку.
\end{enumerate}

Основной алгоритм:

\begin{enumerate}
	\item Шаг <<square>>;
	\item шаг <<diamond>>;
	\item уменьшить значение шума;
	\item уменьшить значение $step wide$ вдвое.
	\item повторять эти действия пока ширина квадрата больше единицы.
\end{enumerate}

\subsection{Улучшение алгоритма diamond--square}

Хотя алгоритм <<diamond--square>> генерирует реалистичные ландшафты, у них есть излишняя <<шероховатость>>. Для того чтобы побороться с данным явлением был разработан следующий алгоритм сглаживания:

\begin{enumerate}
	\item получить ширину и высоту карты высот;
	\item завести временную карту высот размером со сглаживаемой;
	\item заполнить каждый узел временной карты высот средним значением соответствующего узла из сглаживаемой карты высот и всех смежных с ним узлов из той же сглаживаемой карты;
	\item скопировать в сглаживаемую карту временную.
\end{enumerate}

\subsection{Получение экранных координат по карте высот}

Данные получаемые после алгоритма <<diamond--square>> нуждаются в преобразовании в экранные координаты. Такое преобразование можно осуществить с помощью следующего алгоритма:

\begin{enumerate}
	\item получить карту высот;
	\item создать матрицу трёхмерных точек такой же размерности как карта высот;
	\item получить значения $\Delta x, \Delta y$, как частное размерностей экрана и размерностей карты высот;
	\item получить минимальное и максимальное значения карты высот;
	\item для каждой трёхмерной точки рассчитать её значение как \\ $(i \times \Delta x, j \times \Delta y, ((H_{max} - H_{min}) \times H_{screen})$, где $i$ -- индекс соответствующего узла по строке, $j$ -- индекс соответствующего узла по столбцу, $H_{screen}$ -- заранее предопределённая величина для матрицы трёхмерных точек.
\end{enumerate}

\subsection{Алгоритм использующий Z буфер}

\begin{enumerate}
	\item Заполнить буфер кадра значением фона;
	\item заполнить Z буфер минимальным значением;
	\item для каждого пикселя растровой развертки объектов сцены сравнить глубину Z(x,y) с Z буфера в той же точке, если Z(x,y) > Z буфера (x,y), то заменить Z буфера (x,y) на z(x,y) и заменить цвет буфера кадра (x,y) на цвет текущего пикселя. 
\end{enumerate}

\subsection{Получение цвета для полигона}

Важной частью реалистичного ландшафта, является палитра цветов, используемая для его отображения. В качестве палитры я взял палитру типичную для топографических карт. Сама палитра представляет из себя зависимость цвета от высоты. Высоты распределены от $0$ до $1$.

Алгоритм получения цвета полигона от по его высоте:

\begin{enumerate}
	\item вычислить высоту полигона как среднее значение из высот его вершин;
	\item определить по таблице с палитрой между какими табличными высотами находится высота полигона; 
	\item совершить линейную интерполяцию между этими табличными значениями по цвету, результатом будет значение цвета для данного полигона.
\end{enumerate}

\subsection{Модель освещения Ламберта}

Для каждого пикселя растровой развёрстки посчитать интенсивность по формуле~(\ref{eq:lambert}).

\begin{equation}
		I = I_0 \times K_d \times \cos{\theta}
	\label{eq:lambert}
\end{equation}

Где $I_0$ -- начальная интенсивность света, $K_d$ -- коэффициент диффузного отражения, $\theta$ -- угол между вектором нормали поверхности и вектором образованным центром поверхности и источником света.

\subsection{Улучшения освещения}
Учитывая алгоритм работы с моделью Ламберта очевидно, что если посмотреть на карту с обратной стороны, то она будет окрашена в те же цвета, что и лицевая, чтобы исправить это, был добавлен <<корректирующий вектор>> и вектор направления камеры.

{\bfseries Корректирующий вектор}

Изначально $V_{corr} = (0, 0, 1)$, однако при каждом аффинном преобразовании (исключая перенос), аналогичное преобразование применяется и к корректирующему вектору, действует правило, что центр масштабирования и поворота для данного вектора всегда находится в точке $C = (0, 0, 0)$.

Введения данного вектора требует внесения следующего изменения в алгоритм расчёта нормали для полигона:

\begin{enumerate}
	\item получить нормаль для очередного полигона;
	\item рассчитать скалярное произведения вектора нормали полигона и корректирующего вектора;
	\item в случае отрицательности полученного произведения, инвертировать координаты вектора.
\end{enumerate}

{\bfseries Камера}

Для того чтобы правильно отобразить обратную стороны ландшафта требуется учитывать направление взгляда наблюдателя. Направления взгляда наблюдателя было введено через абстрактную камеру. У камеры есть вектор, отвечающий за то куда она направленна. Для поставленной задачи это направление константно и равно: $V_{cam} = (0, 0, -1)$.

С учетом этих улучшений алгоритм получения интенсивности полигона был модифицирован следующим образом:

\begin{enumerate}
	\item получить вектор нормали для данного полигона;
	\item высчитать скалярное произведение для вектора нормали и инвертированного вектора направления камеры;
	\item если результат полученного произведения отрицателен присвоить данному полигону интенсивность равную $0$, т.~е. лицевая сторона данного полигона находится вне поля зрения наблюдателя.
\end{enumerate}

\subsection{Алгоритм движения источника света}

Чтобы промоделировать движение источника вокруг заданной оси, нужно изменять его положение раз в какое-то время, в случае поставленной задачи изменение происходит раз в одну секунду. Для вычислений новых параметров ландшафта необходимо завести отдельный поток для достижения удобства пользования программным обеспечением.

\subsection{Сохранение истории операций над ландшафтом}
При изменении ландшафта, при вводе параметров могут возникнуть ошибки на стороне пользователя, для того чтобы удобно их править была введена история операций над ландшафтом.

Сами операции сохраняются как данные необходимые для совершения этой операции, а так же сохраняется позиция источника света которая была установлена до совершения операции.

Для каждой сохранённой операции должен быть определён метод \textit{do} и \textit{undo}. Из названия ясно, что они позволяют совершить сохранённое преобразование над ландшафтом и обратное преобразование от сохранённого соответственно.

\subsection{Сохранение и загрузка ландшафта}

Ландшафт сохраняется в виде текстового файла в который записывается размер карты высот и сама карта высот. При загрузке карты значения считываются из файл в объект ландшафта.

\section{Представление данных в программном обеспечении}

\begin{table}[H]
	\begin{center}
		\begin{threeparttable}
			\caption{Представление данных в программе}
			\label{tbl:data}
			\begin{tabular}{|c|c|}
				\hline
				\bfseries{Данные} & \bfseries{Представления} \\
				\hline
				Карта высот &  Матрица вещественных значений \\
				\hline
				Точка в пространстве & Трёхмерный вектор \\
				\hline
				Источник света & Точка в пространстве \\
				\hline
				Камера & Трёхмерный вектор \\
				\hline
				История операций & Вектор указателей на класс операций \\ 
				\hline
				
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

\section*{Вывод}

В конструкторской части работы были представлены требования к программе, описания алгоритмов, выбранные типы и структуры данных.
